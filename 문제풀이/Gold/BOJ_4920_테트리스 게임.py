# 테트리스 게임
'''
    [풀이과정]
    - 어떻게 풀어야 하는지 대충 감은 잡았는데, 문제는 그것이 "시간" 내에 풀 수 있는지 의문이었음
    - 너무 많은 경우의 수에 대해서, 직접 일일이 "구현", "시뮬레이션"으로 푸는 게 맞나? 싶어서... 머뭇거리다가 결국 힌트 봤음
    - 이 문제가 "구현", "브루트포스" 유형이라는 것을 보고는, 내가 생각한 방법이 맞다고 판단. (--> 이미 여기서부터 내 힘으로 100% 문제 해결 했다고 생각하지 않음)
    - 가능한 13가지 경우에 대해서, dy, dx 쌍을 모두 만들어 두고, 그것을 반복문 돌리면서 최댓값을 구하면 되지 않나 하는 생각을 함
'''

# dy, dx 쌍 미리 선언 --> 13줄이나 되는 복잡한 배열이라 세로로 보기 좋게 정렬해 놓았음
dy = [
    [0,0,0,0],
    [0,1,2,3],
    [0,0,1,1],
    [2,1,1,0],
    [0,0,0,1],
    [2,2,1,0],
    [0,1,1,1],
    [2,1,0,0],
    [0,0,0,1],
    [1,2,1,0],
    [1,1,1,0],
    [2,1,0,1],
    [0,0,1,1]
]
dx = [
    [0,1,2,3],
    [0,0,0,0],
    [0,1,1,2],
    [0,0,1,1],
    [0,1,2,2],
    [0,1,1,1],
    [0,0,1,2],
    [0,0,0,1],
    [0,1,2,1],
    [0,1,1,1],
    [0,1,2,1],
    [0,0,0,1],
    [0,1,0,1]
]

tc = 1 # 테스트 케이스 번호 --> 루프 한 번 끝날 때마다 +1씩 할거임
while True: # 마지막 입력에 0이 주어질 때까지 여러 테스트 케이스 반복
    n = int(input())
    if n == 0: # 0이면, 탈출
        break
    board = []
    for _ in range(n): # n개의 줄에 걸쳐서 표의 값들이 주어짐
        row = list(map(int, input().split()))
        board.append(row)

    max_sum = -4000001 # 숫자는 절댓값이 100만이 넘지 않는 정수, 최소 값은 -400만
    # 보드 모두 탐색, 그리고 그 탐색하는 도중에 가능한 모든 쌍에 대해서 Brute-Force --> O(100*100*13*4) = O(52만) 정도로 시간 초과 걱정 안해도 될 듯!
    for i in range(n):
        for j in range(n):
            for k in range(13): # 가능한 13가지 경우에 대해서 모두 탐색하기
                sum = 0
                for l in range(4):
                    ny = i+dy[k][l]
                    nx = j+dx[k][l]
                    if ny < 0 or ny > n-1 or nx < 0 or nx > n-1: # 합을 구하는 도중 경계를 벗어났다면
                        sum = -1
                        break
                    sum += board[ny][nx] # 해당하는 좌표에서 값을 계산한다
                if sum != -1: # 합을 구하는 것이 가능하다고 판단된 경우에만
                    max_sum = max(max_sum, sum) # --> 최댓값 갱신

    print(f"{tc}. {max_sum}") # 가장 큰 합 출력
    tc += 1