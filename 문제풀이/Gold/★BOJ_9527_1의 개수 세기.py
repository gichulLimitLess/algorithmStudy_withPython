# 1의 개수 세기
'''
    큰 범위에서 (애초에 이 문제는 1000조 까지의 수를 상정하고 있음)
    --> '구조적으로 반복되는 규칙'을 수학적 누적식으로 바꾸는 문제
    ==> 이런 문제에서는.. F(N) = 1부터 N까지 등장하는 모든 1의 개수로 상정하고
    --> 답 = F(B) - F(A-1)을 구하는 문제로 탈바꿈 시켜야 한다
'''
import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

A, B = map(int, input().split())

# dp[k] = 0부터 (2^k - 1)까지의 모든 수를 이진수로 표현했을 때 등장하는 '1'의 총 개수
# dp[0] = 0  (0 하나만 존재하며, 1이 없음)
MAX_K = 60  # 2^60 ≈ 1.15e18 > 1e16 이므로 충분한 범위
dp = [0] * (MAX_K + 1)

# 점화식:
# dp[k] = 2 * dp[k-1] + 2^(k-1)
# → 앞 절반(0 ~ 2^(k-1)-1) + 뒤 절반(패턴 반복 + MSB 1 고정)
for k in range(1, MAX_K + 1):
    dp[k] = 2 * dp[k - 1] + (1 << (k - 1))


def F(n: int) -> int:
    """
    1부터 n까지의 모든 수를 이진수로 표현했을 때
    등장하는 '1'의 총 개수를 반환하는 함수
    """
    if n <= 0:
        return 0

    # n의 최상위 비트 위치 (2^k)
    k = n.bit_length() - 1
    p = 1 << k  # p = 2^k

    # [0 ~ (2^k - 1)] 구간의 1의 개수: dp[k]
    # [2^k ~ n] 구간에서
    #   - 최상위 비트(MSB)가 1인 개수: (n - p + 1)
    #   - 나머지 하위 비트의 기여: F(n - p)
    return dp[k] + (n - p + 1) + F(n - p)


# 최종 정답: F(B) - F(A - 1)
print(F(B) - F(A - 1))

