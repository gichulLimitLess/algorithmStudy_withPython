# Z
'''
    [사고과정]
    단순하게 1 <= n <= 15 범위에서 다 DFS 탐색하게 되면.. 4^15 --> O(10억)
        => 0.5초 시간 제한 있는 이 문제에선 당연히 터짐
    다른 방법? 수식화 해서 뭔가 구할 수 있을 것 같음
        => 패턴을 발견해 보자
'''
# n이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력해야 함
n, r, c = map(int, input().split())

# 일일이 찾으러 들어가지 말고, 특정 행/열에 오는 값을 어느 정도 미리 계산 가능
# --> 해당 (r,c)가 있는 2*2 블록의 왼쪽 상단이 몇 번째로 방문하는지 계산 가능
# ==> 이런 문제는 보통 "재귀" 혹은 "분할 정복"으로 풀어야 한다고 한다!
# ========== 1. 재귀 풀이 ==========
N, r, c = map(int, input().split())

def sol(N, r, c):
    if N == 0:
        return 0

    return 2 * (r % 2) + (c % 2) + 4 * sol(N - 1, int(r / 2), int(c / 2))

print(sol(N, r, c))

# ========== 2. 분할 정복 풀이 ============
N, r, c = map(int, input().split())

ans = 0

while N != 0:

    N -= 1

    # 제2사분면
    if r < 2 ** N and c < 2 ** N:
        ans += (2 ** N) * (2 ** N) * 0

    # 제1사분면
    elif r < 2 ** N and c >= 2 ** N:
        ans += (2 ** N) * (2 ** N) * 1
        c -= (2 ** N)

    # 제3사분면
    elif r >= 2 ** N and c < 2 ** N:
        ans += (2 ** N) * (2 ** N) * 2
        r -= (2 ** N)

    # 제4사분면
    else:
        ans += (2 ** N) * (2 ** N) * 3
        r -= (2 ** N)
        c -= (2 ** N)

print(ans)