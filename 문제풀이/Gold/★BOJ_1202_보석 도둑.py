# 보석 도둑
'''
    [사고 과정]
    - 우선, 완전 탐색을 통해서 다 확인하는 건 안된다는 것을 캐치했다
        --> 반사적으로, 여기서 자동적으로 나는 dp가 그리디를 떠올렸다.
        --> 그러나, dp나 그리디를 만족하는지 조건도 애매하고
            (부분 문제가 만들어지는 것 같질 않았고, 그리디로 풀기 위해 각 경우가 모두 독립적인 것 같지도 않았다)
    - 그래도 우선, 무작정 완전탐색 하는 것은 불가하기에 (시간 반드시 초과)
        정렬하는 방법도 생각해 보았다.
        그런데, 생각해보면.. 가방과 보석을 '무게' 기준으로 오름차순 정렬시켜놓고.. --> (O(2*30만*log30만))
            가방 정보와 보석 정보를 각각 처음부터 훑어보며.. (-> 이거 해봐야.. O(30만)이다)
                if 현재 확인 중인 가방의 무게 >= 현재 확인 중인 보석 무게이면..
                    지속적으로 현재 가방에 넣을 수 있는
                    보석의 가치를 최대한 큰 걸로 갱신하고 (최대 1개만 넣을 수 있으니까)
                아니라면..
                    다음 가방 기준으로 확인을 지속하면 되지 않나는 생각을 했다
                    (왜냐면, 뒤에 있는 보석들 중에 현재 가방에다가 넣을 수 있는 건 더 이상 없기 때문)

    - (위의 알고리즘이 잘못 되었다는 것을 알고 재시도)
        - 위의 알고리즘을 통해서 풀면,
            이전에 확인하고 넘어간 보석 중에서, 뒤에 들어갔을 때 더 큰 가치를 만들어낼 수 있는 경우를 누락시킬 수 있음
        - 문제 목표 재정의: "가치"가 높은 것들을 최대한 "많이" 넣어야 한다
            --> 뭔가 말에서 '그리디'의 냄새가 나지 않나요?
        - 보석을 '가치' 순으로 내림차순 정렬을 한 번 해볼까?
            그런 다음.. 가치가 가장 높은 보석부터 보면서..
            이 보석을 넣을 수 있는 가방 중에서, 가장 최대 무게가 작은 가방을 선택해 나아가면 되지 않을까?
            (-> 이렇게 선택하게 되면, 가치가 큰 보석들을 최대한 많이 넣을 수 있다는 걸 알 수 있다)
        - 우선순위 큐 써야 하나? 그런데 어떻게 써야 하지?

    - 힌트를 봤음
        - 보석과 가방 무게를 '오름차순'으로 정렬하고,
          각 가방에 들어갈 수 있는 보석들을 해당 가방 무게의 최대 무게 초과 안할 때까지 '최대 힙'에 넣는다
          그 다음, 넘어가면, 최대 힙에서 빼낸 원소를 본다. (그게 해당 가방에 들어갈 값이다)
'''
import heapq

# 정보 입력 받기
n, k = map(int, input().split())
jew_list = [] # 보석들이 (무게, 가치) 정보들을 저장
bag_list = [] # 가방의 '무게' 정보들을 저장
res = [0 for _ in range(k)] # 각 가방에 들어간 최종 보석들의 '가치'를 저장
bag_p = 0
jew_p = 0
for _ in range(n): # 보석 정보 Mi, Vi 입력 받기
    m, v = map(int, input().split())
    jew_list.append((m, v))

for _ in range(k): # 가방에 담을 수 있는 최대 무게 정보 Ci 입력 받기
    c = int(input())
    bag_list.append(c)

# 이 풀이의 핵심 --> 가방과 보석을 '무게' 기준으로 오름차순 정렬시키자 (O(2*30만*log30만))
jew_list.sort()
bag_list.sort()
temp = []
result = 0

# 모든 가방 정보를 확인할 때까지 --> '최대 힙' 사용 (O(NlogN + KlogN))
for bag in bag_list:
    # 보석 정보가 아직 남아있고, 현재 가방에 들어갈 수 있는 애들만 탐색 --> 계속 맨 앞에꺼 빼내기
    while jew_list and jew_list[0][0] <= bag:
        # '최대 힙'으로 사용할 것이므로, 음수로 저장 / 이후 jew_list 맨 앞에꺼 빼내기
        heapq.heappush(temp, -jew_list[0][1])
        heapq.heappop(jew_list)
    # 넣을 수 있는 후보군 다 넣었으면, temp를 확인한다
    # (temp에는 이전에 제거된 '들어갈 수 있는 후보군'들이 남아있을 수 있다
    # --> 그것의 가치가 더 크다면, 그것을 알아서 뽑아줄 것이다. 최대 힙이니깐!)
    if temp:
        ans = -heapq.heappop(temp) # '최대 힙'으로 저장해 놨으므로, - 붙여서 반전해 줘야 함
        result += ans

# 위 과정을 거치고 나면, result에 저장되어 있는 값이 각 가방에 저장할 수 있는 '보석 가치의 최대'
print(result)