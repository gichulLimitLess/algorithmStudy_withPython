# LCS 2
'''
    [다시 푸는 문제]
    -> "편집 거리"와 비슷하게 푸는 문제였음
    -> 2차원 dp 테이블을 만드는 것으로 패턴 적용해보기
        dp[i][j] -> A의 i번째 문자까지의 부분 문자열,
                    B의 j번째 문자까지의 부분 문자열을 고려했을 때, LCS 길이
    -> 전이식
        A[i] == B[j]라면..
        왼쪽 대각선 방향의 dp[i-1][j-1] 값에 +1 해서 dp[i][j]에 저장
        아니라면...
        dp[i-1][j], dp[i][j-1] 값 중에서 더 큰 값으로 갱신
    -> LCS 구하기
        길이를 구해가는 과정에서 모두 집어넣고, 비교하는 연산을 할 경우, 각 상황에 대한 부분 LCS 필요
        이럴 경우에는.. dp 테이블에 더해, 부분 문자열 테이블까지 상황별로 모두 필요할 수 있음 (--> 메모리 터질 듯)
        LCS 문자열 자체는.. 지금까지 dp 테이블을 채워온 방식을 역이용 하면 된다 / 백트래킹 써보자
        현재 위치의 문자열이 서로 같다면.. 대각선 방향으로 올라가고 해당 위치의 문자열을 넣는다
        다르다면.. 대각선 방향으로 올라가면서, 해당 칸의 문자를 answer_rev에 넣기 --> 0번째 행 or 0번째 열까지 갔으면 백트래킹 종료
'''

A = input()
B = input()
# 아예 빈칸도 포함해야 함
dp = [[0 for _ in range(len(B)+1)] for _ in range(len(A)+1)]

# dp 테이블 채우기
for i in range(1, len(A)+1):
    for j in range(1, len(B)+1):
        if A[i-1] == B[j-1]:
            dp[i][j] = dp[i-1][j-1] + 1 # 대각선에서 값 땡겨오기 -> 그러고 +1
        else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])

print(dp[-1][-1]) # LCS의 길이 우선 출력
if dp[-1][-1] != 0: # 길이가 0이 아니면, LCS 자체를 출력
    answer_rev = []
    # 백트래킹 실시
    sy = len(A)
    sx = len(B)
    while sy != 0 and sx != 0: # 첫번째 행 또는 열에 가기 전까지 반복
        # 대각선 방향에서, 값이 같은 게 아니라.. 지금 현재 위치에서 비교하고 있는 "문자"가 같은지 확인해야 한다
        if A[sy-1] == B[sx-1]:
            answer_rev.append(A[sy-1])
            sy -= 1
            sx -= 1
        else: # 이외의 경우, 왼쪽 or 위쪽으로 가봐야 한다 (해당하는 칸의 문자는 포함 시키지 X)
            if dp[sy - 1][sx] > dp[sy][sx - 1]:  # 위쪽이 왼쪽보다 값이 더 큰 경우
                sy -= 1
            else:
                sx -= 1

    answer_rev.reverse() # 뒤집는다
    print(''.join(answer_rev)) # 결과 출력