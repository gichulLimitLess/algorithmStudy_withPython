# 호텔
'''
    [풀이과정]
    호텔의 고객을 적어도 C명 늘리기 위해 형택이가 투자해야 하는 돈의 최솟값 구하기 (1 <= C <= 1000)
    형택이가 홍보할 수 있는 도시 개수: n (1 <= n <= 20)
    --> 이걸 처음에는.. 도시 개수가 최대 20이니까, DFS로 풀 수 있다고 생각했다.
        그런데, 생각해보니 그럴려면 20+20^2+20^3+20^4+..+20^20의 모든 경우의 수를 구해야 한다
        이러면 당연히 시간이 터지겠죠?
    --> 시간이 터지니, 바로 DP로 전환해야 한다. DP로 풀기 위해서는 dp 테이블의 축을 설정해야 했다
        손으로 쓰면서 한 번 유도해 보니, 아래와 같은 dp 상태를 정의할 수 있었다.
        dp[i][j] = info_list의 i+1번째 도시까지를 고려했을 때, 늘어나는 고객이 j명이 되기 위해 드는 비용의 최솟값 (j는 최대 1000, i는 최대 20)
        --> i는 0~n-1, j는 0~1000
'''
c, n = map(int, input().split())
info_list = []
for _ in range(n):
    cost, cust_num = map(int, input().split())
    info_list.append((cost, cust_num)) # (비용, 늘어나는 고객 수) 저장

INF = float('inf')
dp = [[INF for _ in range(100*20+1)] for _ in range(n)] # '적어도' c명이므로, 그 이상의 경우들도 고려해야 함 -> 그 이상에서 더 적은 값이 나올수도 있음

# dp 테이블 초기값 세팅
for i in range(n):
    dp[i][0] = 0 # 늘어나는 고객이 0명이 되기 하기 위해서는, 모든 경우에서 cost가 0이 든다고 표기

for j in range(1, 2001): # 첫째 행 초기화
    dp[0][j] = info_list[0][0] * (j // info_list[0][1]) if j % info_list[0][1] == 0 else INF

# dp 테이블 채워 나가기 --> 최대 O(n*2000) 소비될 것임
for i in range(1, n):
    for j in range(1, 2001):
        if j >= info_list[i][1]: # info_list[i][1] 칸 만큼 이전에 있는 값을 가져올 수 있는 경우
            '''
            [전이식]
                dp[i][j] => 이전 행에서 j명을 만들 때 들었던 최솟값(dp[i-1][j])과, 
                            현재 행에서 j-info_list[i][1]명을 만들 때 들었던 최솟값에서 info_list[i][0] 만큼의 비용을 더한 값 중
                            최솟값을 선택
            '''
            dp[i][j] = min(dp[i-1][j], dp[i][j-info_list[i][1]] + info_list[i][0])
        else: # 아닌 경우
            dp[i][j] = min(dp[i-1][j], dp[i][j]) # 현재 칸과 이전 행에서 구한 값 중 최소 가져오기 (-> 둘 다 없으면 INF 저장될 것임)

print(min(dp[n-1][c:2001])) # 이것이 우리가 원하는 정답 --> n-1번째 도시까지 홍보하는 것을 고려했을 때, 늘어나는 고객이 적어도 c명이 되기 위해 드는 비용의 최솟값

# ==================== 아래는 GPT와 함께한 최적화 버전 (dp 배열을 1차원으로..) =========================
# 🏨 [백준 1106 - 호텔]
# 목표: 적어도 C명의 고객을 유치하기 위한 최소 비용 구하기
# 유형: 무한 배낭(Unbounded Knapsack) + 최소비용 DP

# --------------------------------------------------------
# ✅ 핵심 아이디어
# dp[j] = 고객 j명을 달성하기 위한 최소 비용
# 각 도시(cost, cust)를 "무한히 사용할 수 있음"
# 따라서 각 도시를 순회하면서 가능한 고객 수 j의 모든 상태를 갱신
# 전이식: dp[j] = min(dp[j], dp[j - cust] + cost)
# --------------------------------------------------------

C, N = map(int, input().split())  # 목표 고객 수, 도시 개수
info_list = [tuple(map(int, input().split())) for _ in range(N)]

INF = float('inf')

# dp[j]: 고객 j명을 유치하는 데 필요한 최소비용
# '적어도 C명'을 구해야 하므로, 약간 여유 있게 (C + 100)까지 선언
dp = [INF] * (C + 100)
dp[0] = 0  # 고객 0명을 유치하기 위한 비용은 0

# --------------------------------------------------------
# 🔁 DP 갱신 시작
# - 각 도시를 한 번씩 꺼내면서
# - 해당 도시를 여러 번 쓸 수 있게 (무한히) dp 배열을 갱신한다.
# --------------------------------------------------------
for cost, cust in info_list:
    # j는 "현재 확보한 고객 수"를 의미
    for j in range(cust, C + 100):
        # 만약 j-cust 고객을 만드는 최소비용이 존재한다면,
        # 그 상태에서 현재 도시를 한 번 더 사용했을 때 비용으로 갱신 가능
        dp[j] = min(dp[j], dp[j - cust] + cost)

# --------------------------------------------------------
# ✅ 정답 출력
# - '적어도 C명'을 달성해야 하므로
#   C 이상 구간(dp[C], dp[C+1], ...) 중 최소값이 실제 답이 된다.
# --------------------------------------------------------
print(min(dp[C:]))

