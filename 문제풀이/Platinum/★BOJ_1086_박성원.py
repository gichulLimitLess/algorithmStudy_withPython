# 박성원
'''
    (백준 풀다가... 열받아서.. 플레 문제 하나는 풀겠다는 마인드로 잡은 문제)
    --> 순열을 숫자로 조합해서, 합친 수가 정수 K로 나누어 떨어지는지 구하는 문제
    --> 겉으로는 되게 단순해 보이는 문제이나.. 생각해보면, 집합 안에 각 숫자는 최대 길이가 50, 50짜리를 15개 합치면.. 길이는 최대 750자리
    --> 750자리의 수는.. 10^750 이상의 크기를 가지고 있음, 2^64(64비트)의 수로도 표현이 불가능함
    --> 어떻게 풀어야 할까? "나누어 떨어진다"라는 냄새를 맡고, 나머지 연산(mod)을 생각해야 하고,
        "나머지 연산"에서 유용하게 활용할 수 있는 "모듈러 연산 법칙"을 적용하면 좋지 않을까 하는 생각이 들었다.
'''

# n = int(input()) # 집합의 수의 개수 n (1 <= n <= 15)
# num_set = [] # 이거는 집합이라고는 했으나, 사실 배열로 표현해도 무방함
# for _ in range(n):
#     num_set.append(int(input()))
# k = int(input()) # 합친 수가 정수 k로 나누어 떨어지는지 확인해야 함 --> 1 <= k <= 100

from math import gcd, factorial

# 입력: 숫자 개수 n (1 ≤ n ≤ 15)
n = int(input())

# 숫자들을 문자열로 입력받음
#   → 정수로 바로 바꾸지 않는 이유: 뒤에서 각 숫자의 길이를 알아야 하므로
nums = [input().strip() for _ in range(n)]

# 목표 나눗셈 기준 k (1 ≤ k ≤ 100)
k = int(input())

# ---------------------------------------------------
# 🔹 Step 1. 전처리: 각 숫자의 '나머지'와 '길이' 미리 계산
# ---------------------------------------------------

mod_val = []  # 각 숫자를 k로 나눈 나머지
length = []   # 각 숫자의 길이

for num in nums:
    mod_val.append(int(num) % k)   # ex) "123" -> 123 % k
    length.append(len(num))        # ex) len("123") = 3

# 10^len % k 미리 계산
#   → 숫자를 '붙일 때' 필요한 곱셈을 빠르게 하기 위해
ten_pow = [pow(10, l, k) for l in length]
# 예: "12" 뒤에 "345" 붙일 때 → (12 * 10^3 + 345)
#     여기서 10^3 % k 값은 미리 저장해둬야 속도가 빠름

# ---------------------------------------------------
# Step 2. DP 테이블 정의
# ---------------------------------------------------

# dp[mask][r] = mask로 표현된 집합의 숫자들을 어떤 순서로 배치했을 때,
#               나머지가 r이 되는 경우의 수
# mask: n비트 정수 → 각 숫자 사용 여부를 나타냄
#       예) n=4일 때 mask=1011(2) → {0,1,3번째 숫자 사용}
# r: 0 ≤ r < k

dp = [[0] * k for _ in range(1 << n)]  # 전체 크기: (2^n) × k
dp[0][0] = 1  # 아무것도 안 붙였을 때 나머지가 0인 경우 1개

# ---------------------------------------------------
# Step 3. DP 전이
# --> 모든 순열을 실제로 생성하지 않고, 그 효과를 DP로 누적하는 문제
# ---------------------------------------------------

# 모든 mask (부분집합 상태)에 대해 탐색
for mask in range(1 << n):
    # 현재 mask 상태에서의 모든 나머지 r에 대해 탐색
    for r in range(k):
        if dp[mask][r] == 0:
            continue  # 경우의 수가 0이면 건너뛴다

        # 다음에 사용할 숫자 j 선택
        for j in range(n):
            # 아직 사용하지 않은 숫자라면 (mask에서 j번째 비트가 0이면)
            if not (mask & (1 << j)):
                new_mask = mask | (1 << j)  # j번째 숫자 사용 표시

                # 새로운 나머지 계산
                # (기존 나머지 * 10^len[j] + 새 숫자의 나머지) % k
                new_r = (r * ten_pow[j] + mod_val[j]) % k

                # 새로운 상태로 경우의 수를 누적
                dp[new_mask][new_r] += dp[mask][r]

# ---------------------------------------------------
# Step 4. 결과 계산
# ---------------------------------------------------

# 모든 숫자를 다 사용한 경우의 mask = (1<<n) - 1
# 그 중에서 나머지가 0인 경우가 우리가 원하는 “성공 케이스”
p = dp[(1 << n) - 1][0]  # 분자 (성공 경우의 수)
q = factorial(n)         # 분모 (전체 순열의 개수 = n!)

# ---------------------------------------------------
# Step 5. 기약분수로 출력
# ---------------------------------------------------

if p == 0:
    # 나누어 떨어지는 경우가 하나도 없다면 0/1 출력
    print("0/1")
else:
    g = gcd(p, q)  # 최대공약수로 약분
    print(f"{p // g}/{q // g}")
